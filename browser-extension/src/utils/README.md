# Credential Management

This document outlines how credentials are created, stored, and managed within the Keyvault browser extension.

## Credential Types

The system supports several types of credentials, all inheriting from a `BaseCred` type. The primary credential types are:

- **`PasswordCred`**: For storing website login information (URL, username, password).
- **`KeypairCred`**: For storing cryptographic key pairs (public and private keys).
- **`SecretShareCred`**: For storing shares of a secret created using Shamir's Secret Sharing.
- **`ContactCred`**: For storing contact information.

Each credential has a `version`, `type`, `id`, and `timestamp`.

Credentials not yet stored on-chain are bundled into a list before being encrypted and stored on-chain.

## Credential Lifecycle

### Creation

New credentials are created using dedicated functions like `createNewPasswordCred` and `createKeypairCred`. A unique `id` is generated using `crypto.getRandomValues()`, and the current `timestamp` is recorded.

### Updates

When a credential is updated (e.g., changing a password), a new credential object is created with the same `id` but with the updated information and a new `timestamp`. The system maintains a history of changes, and the most recent version of a credential is the one with the highest timestamp.

Credentials with the same `id` form a "chain". For example, updating a password for a website doesn't change the credential's `id`, but it creates a new entry in its chain with the new password and a new timestamp.

### Deletion

Credentials are not physically deleted from storage. Instead, a "deletion" record is created. For `PasswordCred`, this is a `PasswordDeletionCred` object which has `isDeleted` set to `true`. This acts as a tombstone, indicating that the credential with that `id` should be considered deleted.

## Compression

Before encryption, credential objects are "shortened" to reduce their size. This is done using the `createKeyShortener` utility, see `credentials.test.ts`. It converts a credential object into an array, where the order of values is determined by a predefined index (e.g., `passwordIndex`). `null` or `undefined` values at the end of the array are omitted to save space.

For example, a `PasswordCred` object:

```json
{
  "version": 1,
  "type": 0,
  "id": 1458711260,
  "timestamp": 1,
  "isDeleted": false,
  "url": "https://example.com",
  "username": "user1",
  "password": "pass1",
  "description": "Credential 1"
}
```

is shortened to:

```json
[
  1,
  0,
  1458711260,
  1,
  false,
  "https://example.com",
  "user1",
  "pass1",
  "Credential 1"
]
```

## Encryption

The shortened credential arrays are encrypted using `AES-GCM` with a 256-bit key. The `encryptEntries` function takes an array of credentials, shortens them, and then encrypts the result. The encryption process uses `msgpack` to serialize the data before encryption for efficiency.

Each encrypted payload contains the `iv` (initialization vector) and the `ciphertext`.

## Storage & Process

Encrypted credentials are stored on a smart contract on the blockchain. The extension retrieves these encrypted entries, decrypts them locally, and reconstructs the credential objects.

After decryption, credentials are organized into various data structures for efficient use within the browser extension. The raw, decrypted data is first held in a simple array, which is then transformed into more complex structures for UI presentation and quick lookups.

### From Smart Contract to `Cred[]`

The data stored on the smart contract is a series of encrypted blobs. After being fetched, each blob is decrypted, decompressed (from its array format back to an object), and validated. All the valid credential objects are collected into a single flat array, `Cred[]`. This array represents the complete, raw, and unordered set of a user's credentials. The `Cred[]` array is the source of truth from which other data structures are built. When new credentials are to be stored, it is this `Cred[]` array (or a subset of it) that is compressed, encrypted, and sent to the smart contract.

### Client-Side Data Structures

From the `Cred[]` array, the following structures are derived for client-side operations:

- **`CredsByUrl` (`Record<string, PasswordCred[][]>`):** This structure organizes `PasswordCred` objects for easier access in the UI. It's a dictionary where:

  - The keys are website URLs.
  - The values are an array of credential chains (`PasswordCred[][]`). Each inner array is a single credential chain (all records with the same `id`), sorted chronologically. The outer array is sorted in reverse chronological order based on the latest update in each chain. This structure is generated by the `getCredsByUrl` function.

- **`CredsMapping` (`Record<string, [string, number]>`):** This is a lookup table that maps a credential `id` to its location within the `CredsByUrl` structure.
  - The key is the credential `id`.
  - The value is a tuple `[url, chainIndex]`, allowing for efficient updates and retrieval of a specific credential chain. This is generated by `getMappingFromCredsByUrl`.

These structures allow the application to efficiently display and manage credential data without repeatedly processing the raw `Cred[]` array.

### Compression and Encryption

Before being stored on the smart contract, credentials go through several steps:

1.  **Compression (Shortening):** To save space and reduce transaction costs, each credential object is converted into a compact array format. This "shortening" process removes keys and trims trailing `null` or `undefined` values.

2.  **Bundling:** Multiple shortened credential arrays are bundled together.

3.  **Serialization and Encryption:** The bundle of credentials is then serialized using `msgpack` and encrypted locally on the client-side using `AES-GCM`.

The final output is an encrypted blob containing multiple credential records from various chains.

### On-Chain Storage

Each of these encrypted blobs is stored as a single string in the `entries` mapping in the smart contract. The contract maintains an array of these strings for each user (`mapping(address => string[]) private entries;`).

The `numEntries` mapping tracks the number of encrypted blobs a user has stored. When new credentials are to be added, they are encrypted and appended to this array via the `storeEntry` function.

The `resetEntries` function allows a user to set their `numEntries` count back to zero. This doesn't clear the stored data but allows the user to start overwriting their existing encrypted entries from the beginning, providing a mechanism for a fresh start.
